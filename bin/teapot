#!/usr/bin/env ruby

# Copyright, 2012, by Samuel G. D. Williams. <http://www.codeotaku.com>
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

require 'teapot/config'

require 'uri'
require 'rainbow'
require 'fileutils'
require 'benchmark'

module Application
	def self.fetch
		config = Teapot::Config.load_default
		context = Teapot::Context.new(config)
	
		base_uri = URI(config.options[:source].to_s)
	
		if base_uri.scheme == nil || base_uri.scheme == 'file'
			base_uri = URI "file://" + File.expand_path(base_uri.path, config.root) + "/"
		end
	
		puts "Base URI: #{base_uri}".color(:cyan)
	
		config.packages.each do |package|
			destination_path = package.path
		
			if package.local?
				puts "Linking local #{package}...".color(:cyan)
			
				local_path = config.root + package.options[:local]
			
				# Make the top level directory if required:
				destination_path.dirname.mkpath
			
				unless destination_path.exist?
					destination_path.make_symlink(local_path)
				end
			else
				puts "Fetching #{package}...".color(:cyan)
		
				branch = package.options.fetch(:version, 'master')
		
				unless destination_path.exist?
					puts "Cloning package at path #{destination_path} ...".color(:cyan)
					destination_path.mkpath
			
					Teapot::Commands.run("git", "clone", package.relative_url(base_uri), destination_path, "--branch", branch)
			
					Dir.chdir(destination_path) do
						Teapot::Commands.run("git", "submodule", "update", "--init", "--recursive")
					end
				else
					puts "Updating package at path #{destination_path} ...".color(:cyan)
			
					Dir.chdir(destination_path) do
						Teapot::Commands.run("git", "fetch", "origin")
				
						Teapot::Commands.run("git", "checkout", branch)
				
						# Pull any changes, if you might get the error from above:
						# Your branch is behind 'origin/0.1' by 1 commit, and can be fast-forwarded.
						Teapot::Commands.run("git", "pull")
				
						Teapot::Commands.run("git", "submodule", "update", "--init", "--recursive")
					end
				end
			end
		end
	
		puts "Completed fetch successfully.".color(:green)
	end
	
	def self.install(package_names = ARGV)
		config = Teapot::Config.load_default
		context = Teapot::Context.new(config)
	
		config.packages.each do |package|
			context.load(package)
		end
		
		context.select(package_names)
		
		chain = Teapot::Dependency::chain(context.selection, context.dependencies, context.targets.values)
	
		if chain.unresolved.size > 0
			puts "Unresolved dependencies:"
		
			chain.unresolved.each do |(name, parent)|
				puts "#{parent} depends on #{name.inspect}".color(:red)
				
				conflicts = chain.conflicts[name]
				
				if conflicts
					conflicts.each do |conflict|
						puts " - provided by #{conflict.inspect}".color(:red)
					end
				end
			end
			
			abort "Cannot continue build due to unresolved dependencies!"
		end
	
		puts "Resolved: #{chain.resolved.inspect}".color(:magenta)
	
		chain.ordered.each do |(target, dependency)|
			puts "Building #{target.name} for dependency #{dependency}...".color(:cyan)
		
			if target.respond_to? :install! and !ENV['TEAPOT_DRY']
				target.install!(context)
			end
		end
	
		puts "Completed build successfully.".color(:green)
	end
	
	def self.list
		config = Teapot::Config.load_default
		context = Teapot::Context.new(config)
	
		config.packages.each do |package|
			targets = context.load(package)
		
			targets.each do |target|
				puts "Target #{target.name} from #{package.name}"
			
				target.dependencies.each do |name|
					puts " - depends on #{name.inspect}".color(:red)
				end
			
				target.provisions.each do |(name, provision)|
					if Teapot::Dependency::Alias === provision
						puts " - provides #{name.inspect} => #{provision.dependencies.inspect}".color(:green)
					else
						puts " - provides #{name.inspect}".color(:green)
					end
				end
			end
		end
	end
	
	def self.debug
		puts ARGV.inspect
	end
end

time = Benchmark.measure do
	action = ARGV.shift.to_sym
	Application.send(action) if Application.methods.include?(action)
end

puts time.format("Elapsed Time: %r").color(:magenta)
